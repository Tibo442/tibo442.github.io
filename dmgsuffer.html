<!doctype html>
<html>
    <head>
        <title>Flat is Justice! - dmg suffer</title>
        <meta name="theme-color" content="#082E6B"/>
        <meta name=viewport content="width=device-width, initial-scale=1">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Flat is Justice - Damage suffering">
        <meta name="twitter:description" content="Calculate suffering of damage based on armor/currhp/maxhp, heavily inspired by http://kancolle-calc.net/suffering.html">
        <meta name="twitter:image" content="http://flatisjustice.moe/pics/dmgsuffer.png">
        <style type="text/css">
            input[type="number"] {
                width:75px;
            }
            canvas {
                margin: 5px;
            }
        </style>
    </head>
    <body>
        <b>Attack info</b><br>
        Cap (fill in 0 when atk = postcap): <input type="number" id="cap" min="0" max="999" onchange="update();" onclick="update();" value=0 step=10><br>
        <div id="postcapdata">
            Take engagement into account: <input type="checkbox" id="engage" onchange="update();" onclick="update();"><br>
            ^ Saiun: <input type="checkbox" id="saiun" onchange="update();" onclick="update();"><br>
            Post-Cap multiplier: <input type="number" id="postcapdmg" min="0" max="10" onchange="update();" onclick="update();" value=1.0 step=0.1><br>
        </div>
        Apply attack twice (like DA/TCI): <input type="checkbox" id="double" onchange="update();" onclick="update();"><br>
        <br>
        <b>Target info</b><br>
        Abyssal: <input type="checkbox" id="abyssal" onchange="update();" onclick="update();"><br>
        Armor: <input type="number" id="armor" min="1" max="9999" onchange="update();" onclick="update();" value=52><br>
        MaxHP: <input type="number" id="maxhp" min="1" max="9999" onchange="update();" onclick="update();" value=38><br>
        CurrHP: <input type="number" id="currhp" min="1" max="9999" onchange="update();" onclick="update();" value=38><br>
        <br>
        <b>Graph</b><br>
        Min attack: <input type="number" id="atkmin" min="0" max="9999" onchange="update();" onclick="update();" value=0 step=5><br>
        Max attack: <input type="number" id="atkmax" min="0" max="9999" onchange="update();" onclick="update();" value=0 step=5><br>
        Color per HP: <input type="checkbox" id="perhp" onchange="update();" onclick="update();"><br>
        <canvas id="graph" width="830" height="425" style="border:1px solid black;"></canvas><br>
        <b>Exact attack bar</b><br>
        Attack: <input type="number" id="exatk" min="0" max="9999" onchange="update();" onclick="update();" value=70><br>
        <canvas id="bar" width="400" height="20" style="border:1px solid black;"></canvas><br>
        <div id="exatk-txt"></div>
        <br><br>
        <i>Formulas used:<br> </i>
        <i>- engagement: </i><code>precapatk = atk * engagement</code> where <code>engagement = x1.2 (15%) x1 (45%) x0.8 (30%) x0.6 (10%)</code> with saiun: <code>engagement = x1.2 (15%) x1 (45%) x0.8 (40%)</code><br>
        <i>- cap: </i><code>postcapatk = floor(<span style="color:red">floor(</span>(precapatk > cap) ? cap + sqrt(precapatk - cap) : precapatk<span style="color:red">)</span> * postcapmultiplier)</code><br>
        <i>- damage: </i><code>dmg = floor(attack - (0.7 * armor + 0.6 * rng.nextInt(armor)))</code><br>
        <i>- scratch: </i><code>if(dmg < 1) -> dmg = floor(0.06 * currentHP + 0.08 * rng.nextInt(currentHP))</code><br>
        <i>- overkill protection: </i><code>if(dmg >= currentHP) -> dmg = floor(0.5 * currentHP + 0.3 * rng.nextInt(currentHP))</code><br>
        <i>where </i><code>nextInt</code><i> returns uniformly, 0 inclusive up to argument exclusive</i><br>
        <br>
        <i>Some formulas come from KC kai's </i><code>setDamageValue</code><i> in </i><code>Server_Controllers.BattleLogic\BattleLogicBase.cs</code><i><br>
        <i>Based on and inspired by <a href="http://kancolle-calc.net/suffering.html">KC-calc suffering</a></i>
        <script type="text/javascript">
            var armor, maxhp, currhp, atkmin, atkmax, exatk, abyssal, cap, saiun, double, postcapdmg, engage, perhp;
            var prevarmor, prevmaxhp, prevcurrhp, prevatkmin, prevatkmax, prevexatk, prevabyssal, prevcap, prevsaiun, prevdouble, prevpostcapdmg, prevengage, prevperhp;
            var context, canvas = document.getElementById("graph"), canvas2 = document.createElement("canvas");
            function update() {
                armor = parseFloat(document.getElementById('armor').value);
                maxhp = parseFloat(document.getElementById('maxhp').value);
                currhp = parseFloat(document.getElementById('currhp').value);
                atkmin = parseFloat(document.getElementById('atkmin').value);
                atkmax = parseFloat(document.getElementById('atkmax').value) + 1;
                cap = parseFloat(document.getElementById('cap').value);
                postcapdmg = parseFloat(document.getElementById('postcapdmg').value);
                abyssal = !!document.getElementById('abyssal').checked;
                saiun = !!document.getElementById('saiun').checked;
                double = !!document.getElementById('double').checked;
                engage = !!document.getElementById('engage').checked;
                perhp = !!document.getElementById('perhp').checked;

                if(prevmaxhp != maxhp || currhp > maxhp) {
                    currhp += maxhp - (prevmaxhp || maxhp);
                    if(currhp > maxhp) currhp = maxhp;
                    document.getElementById('currhp').value = currhp;
                    document.getElementById('currhp').max = maxhp;
                }

                document.getElementById('postcapdata').style = cap <= 0 ? "display:none" : "display:block";
                document.getElementById('saiun').disabled = !engage;

                if(atkmin == 0)
                    atkmin = Math.floor(0.7 * armor) - 2;
                if(atkmax == 1)
                    atkmax = Math.ceil(1.3 * armor + currhp) + 2;
                // console.debug(atkmin,atkmax)
                exatk = parseFloat(document.getElementById('exatk').value);

                let onlyexact = false;
                if(prevarmor == armor && prevdouble == double && prevmaxhp == maxhp && prevcurrhp == currhp
                    && prevatkmin == atkmin && prevatkmax == atkmax && abyssal == prevabyssal && prevsaiun == saiun 
                    && prevcap == cap && prevengage == engage && prevpostcapdmg == postcapdmg && prevperhp == perhp)
                    if(prevexatk == exatk)
                        return;
                    else
                        onlyexact = true;

                prevexatk = exatk;
                prevarmor = armor;
                prevmaxhp = maxhp;
                prevcurrhp = currhp;
                prevatkmin = atkmin;
                prevatkmax = atkmax;
                prevabyssal = abyssal;
                prevcap = cap;
                prevsaiun = saiun;
                prevdouble = double;
                prevpostcapdmg = postcapdmg;
                prevengage = engage;
                prevperhp = perhp;

                let calculated = calculate(exatk);
                document.getElementById('exatk-txt').innerHTML = `
                Green: ${(calculated.ok * 100).toFixed(2)}%<br>
                Shouha: ${(calculated.shouha * 100).toFixed(2)}%<br>
                Chuuha: ${(calculated.chuuha * 100).toFixed(2)}%<br>
                Taiha: ${(calculated.taiha * 100).toFixed(2)}%<br>
                ${calculated.sunk ? ("Sunk: " + (calculated.sunk * 100).toFixed(2) + "%<br>") : ""}<br>
                HP left: ${(calculated.minhp == calculated.maxhp) ? calculated.minhp : calculated.minhp + " ~ " + calculated.maxhp} 
                (Damage: ${(calculated.mindmg == calculated.maxdmg) ? calculated.mindmg : calculated.mindmg + " ~ " + calculated.maxdmg})
                `;

                var bar = document.getElementById("bar");
                bar.width = bar.width;
                bar.height = perhp ? 20 : 10;
                var ctx = bar.getContext("2d");
                let prev = 0;
                ctx.fillStyle = "#2fd30a";
                ctx.fillRect(prev, 0, calculated.ok * bar.width, 10);
                prev += calculated.ok * bar.width;
                ctx.fillStyle = "#d1d100";
                ctx.fillRect(prev, 0, calculated.shouha * bar.width, 10);
                prev += calculated.shouha * bar.width;
                ctx.fillStyle = "#e5a416";
                ctx.fillRect(prev, 0, calculated.chuuha * bar.width, 10);
                prev += calculated.chuuha * bar.width;
                ctx.fillStyle = "#e51616";
                ctx.fillRect(prev, 0, calculated.taiha * bar.width, 10);

                prev = bar.width * (1 - calculated.sunk);
                for(let hp in calculated["hps"]) {
                    let odds = calculated["hps"][hp];
                    if(odds === undefined || hp <= 0)
                        continue;
                    let color = getColor(hp);
                    ctx.fillStyle = "hsl(" + color + ", 100%, 50%)";
                    ctx.fillRect(prev, 10, -odds * bar.width, 10);
                    prev -= odds * bar.width;
                    ctx.fillStyle = "hsl(" + color + ", 100%, 40%)";
                    ctx.fillRect(prev - 2, 10, 3, 10);
                }

                if(onlyexact) {
                    drawArrow();
                    return;
                }

                canvas.width = canvas.width;
                var width = canvas.width - 30;
                var height = canvas.height - 25;
                context = canvas.getContext("2d");

                // var status = [];
                for(let atk = atkmin; atk < atkmax; atk++) {
                    let stages = calculate(atk);
                    
                    // console.log(stages);
                    // status[atk] = stages;
                    prev = 0;
                    if(perhp) {
                        prev = height * (1 - stages.sunk);
                        for(let hp in stages["hps"]) {
                            let odds = stages["hps"][hp];
                            if(odds === undefined || odds <= 0 || hp <= 0)
                                continue;
                            let color = getColor(hp);
                            context.fillStyle = "hsl(" + color + ", 100%, 50%)";
                            context.fillRect(width / (atkmax - atkmin) * (atk - atkmin), prev, width / (atkmax - atkmin) + 1, -odds * height);
                            prev -= odds * height;
                            context.fillStyle = "hsl(" + color + ", 100%, 40%)";
                            context.fillRect(width / (atkmax - atkmin) * (atk - atkmin), prev - 2, width / (atkmax - atkmin) + 1, 3);
                        }
                    } else {
                        context.fillStyle = "#2fd30a";
                        context.fillRect(width / (atkmax - atkmin) * (atk - atkmin), prev, width / (atkmax - atkmin), stages.ok * height);
                        prev += stages.ok * height;
                        context.fillStyle = "#d1d100";
                        context.fillRect(width / (atkmax - atkmin) * (atk - atkmin), prev, width / (atkmax - atkmin), stages.shouha * height);
                        prev += stages.shouha * height;
                        context.fillStyle = "#e5a416";
                        context.fillRect(width / (atkmax - atkmin) * (atk - atkmin), prev, width / (atkmax - atkmin), stages.chuuha * height);
                        prev += stages.chuuha * height;
                        context.fillStyle = "#e51616";
                        context.fillRect(width / (atkmax - atkmin) * (atk - atkmin), prev, width / (atkmax - atkmin), stages.taiha * height);
                        prev += stages.taiha * height;
                    }
                    if(atk % 5 == 0) {
                        context.fillStyle = "#000000";
                        context.save();
                        context.translate(width / (atkmax - atkmin) * (atk - atkmin) + (width / (atkmax - atkmin)) / 2, height + 14);
                        context.rotate(-Math.PI/2);
                        context.textAlign = "center";
                        context.fillText(atk, 0, 3);
                        context.restore();
                    }
                    context.fillStyle = "#000000";
                    context.fillRect(width / (atkmax - atkmin) * (atk - atkmin), 0, 1, height);
                }
                context.fillStyle = "#000000";
                context.fillRect(width, 0, 1, height+1);
                for(let percentage of [1, .75, .5, .25, 0]) {
                    context.fillRect(0, percentage * height, width, 1);
                    context.fillText(percentage * 100 + "%", width + 3, (1-percentage) * height);
                }
                canvas2.width = canvas.width;
                canvas2.height = canvas.height;
                canvas2.getContext("2d").drawImage(canvas, 0, 0)

                drawArrow();
                //console.debug(status);
            }
            function getColor(hp) {
                if(hp / maxhp <= .25) 
                    return (hp/maxhp) * 150;
                else if(hp / maxhp <= .5) 
                    return ((hp-.25*maxhp) / maxhp) * 100 + 50;
                else if(hp / maxhp <= .75) 
                    return ((hp-.50*maxhp) / maxhp) * 300 + 100;
                else 
                    return ((hp-.75*maxhp) / maxhp) * 100 + 190;
            }
            function drawArrow() {
                canvas.width = canvas.width;
                context.drawImage(canvas2, 0, 0);

                if(exatk >= atkmin && exatk < atkmax) {
                    context.fillStyle = "#ff0000";
                    context.fillText("\u2191", (canvas.width - 30) / (atkmax - atkmin) * (exatk - atkmin) + ((canvas.width - 30) / (atkmax - atkmin)) / 2 -2, canvas.height - 15);
                }
            }
            function calculate(atk) {
                let stages = {};
                if(cap) {
                    let engagements = [[1.2, .15], [1, .45], [.8, .3], [.6, .1]];
                    if(saiun) 
                        engagements = [[1.2, .15], [1, .45], [.8, .4]];
                    if(!engage)
                        engagements = [[1, 1]];
                    let capdmg = (uncapped) => Math.floor(uncapped > cap ? cap + Math.sqrt(uncapped - cap) : uncapped);
                    for(let eng of engagements) {
                        let stage = calculateFromPostCapATK(Math.floor(capdmg(eng[0] * atk) * postcapdmg));
                        merge(stages, stage, eng[1]);
                    }
                } else 
                    stages = calculateFromPostCapATK(atk);
                return stages;
            }
            function merge(stages, stage, weight) {
                for(let state of ["ok", "shouha", "chuuha", "taiha", "sunk"])
                    stages[state] = (stages[state]||0) + (stage[state] * weight);
                for(let hp in stage["hps"])
                    stages["hps"][hp] = (stages["hps"][hp]||0) + (stage["hps"][hp] * weight);
                for(let side of ["min", "max"]) {
                    stages[side + "hp"] = compare[side](stages[side + "hp"], stage[side + "hp"]);
                    stages[side + "dmg"] = compare[side](stages[side + "dmg"], stage[side + "dmg"]);
                }
            }
            function calculateFromPostCapATK(atk) {
                if(double) {
                    let firstAttackDMGs = calculateDamagesDone(atk, currhp);
                    // console.debug("First ATK", calculateDamagesDone(atk, currhp));

                    let stages = {
                        "sunk" : 0,
                        "taiha" : 0,
                        "chuuha" : 0,
                        "shouha" : 0,
                        "ok" : 0,
                        "hps" : []
                    };
                    let sum = 0;
                    for(let posdmg in firstAttackDMGs)
                        sum += firstAttackDMGs[posdmg];

                    for(let posdmg in firstAttackDMGs) {
                        let ch = firstAttackDMGs[posdmg], afterhp = currhp - posdmg;
                        let stage = calculatePostCap(atk, afterhp, calculateDamagesDone(atk, afterhp, currhp > 0.25 * maxhp && !abyssal));
                        stage.mindmg = parseInt(stage.mindmg, 10) + parseInt(posdmg, 10);
                        stage.maxdmg = parseInt(stage.maxdmg, 10) + parseInt(posdmg, 10);
                        merge(stages, stage, ch/sum);
                    }
                    return stages;
                } else {
                    return calculatePostCap(atk, currhp);
                }
            }
            function calculatePostCap(atk, currenthp, dmgsDealth = calculateDamagesDone(atk, currenthp)) {
                let sum = 0;
                for(let posdmg in dmgsDealth)
                    sum += dmgsDealth[posdmg];
                let stages = {
                    "sunk" : 0,
                    "taiha" : 0,
                    "chuuha" : 0,
                    "shouha" : 0,
                    "ok" : 0,
                    "hps" : []
                };
                for(let posdmg in dmgsDealth) {
                    let ch = dmgsDealth[posdmg], afterhp = currenthp - posdmg;
                    if(ch == 0) continue;
                    stages["hps"][afterhp] = ch/sum;
                    if(afterhp <= 0)
                        stages.sunk += ch/sum;
                    else if(afterhp <= .25 * maxhp)
                        stages.taiha += ch/sum;
                    else if(afterhp <= .50 * maxhp)
                        stages.chuuha += ch/sum;
                    else if(afterhp <= .75 * maxhp)
                        stages.shouha += ch/sum;
                    else
                        stages.ok += ch/sum;
                    for(let side of ["min", "max"]) {
                        stages[side + "hp"] = compare[side](stages[side + "hp"], afterhp < 0 ? 0 : afterhp);
                        stages[side + "dmg"] = compare[side](stages[side + "dmg"], posdmg);
                    }
                }
                return stages;
            }
            function calculateDamagesDone(atk, currenthp, overkillprot = currenthp > 0.25 * maxhp && !abyssal) {
                let dmgsDealth = {};
                for(let arm = 0; arm < armor; arm++) {
                    let dmg = Math.floor(atk - (0.7 * armor + arm * 0.6));

                    if(dmg >= currenthp && overkillprot) { // Overkill protection
                        let possibledmg = [];
                        for(let hpRoll = 0; hpRoll < currenthp; hpRoll++)
                            possibledmg.push(Math.floor(0.5 * currenthp + 0.3 * hpRoll));
                        for(let posdmg of possibledmg)
                            dmgsDealth[posdmg] = (dmgsDealth[posdmg] || 0) + (1.0 / possibledmg.length);
                    } else if(dmg < 1) { // Scratch
                        let possibledmg = [];
                        for(let hpRoll = 0; hpRoll < currenthp; hpRoll++)
                            possibledmg.push(Math.floor(0.06 * currenthp + 0.08 * hpRoll));
                        for(let posdmg of possibledmg)
                            dmgsDealth[posdmg] = (dmgsDealth[posdmg] || 0) + (1.0 / possibledmg.length);
                    } else {
                        dmgsDealth[dmg] = (dmgsDealth[dmg] || 0) + 1.0;
                    }
                }
                return dmgsDealth;
            }
            const compare = {
                min: function(a, b) {
                    if(isNaN(a)) return b;
                    if(isNaN(b)) return a;
                    if(a == 0 || b == 0)
                        return 0;
                    return Math.min(a||b, b||a);
                },
                max: function(a, b) {
                    if(isNaN(a)) return b;
                    if(isNaN(b)) return a;
                    return Math.max(a||b, b||a);
                }
            }
            update();
        </script>
    </body>
</html>