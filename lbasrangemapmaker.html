<!doctype html>
<html>
    <head>
        <title>Flat is Justice! - lbas range map maker</title>
        <meta name="theme-color" content="#082E6B"/>
        <meta name=viewport content="width=device-width, initial-scale=1">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Flat is Justice - lbas range map maker">
        <meta name="twitter:description" content="Make LBAS range maps">
        <meta name="twitter:image" content="http://flatisjustice.moe/pics/lbasrangemapmaker.png">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.1/pixi.min.js"></script>
        <script src="https://unpkg.com/blob-util/dist/blob-util.min.js"></script>

        <style type="text/css">
            input[type="number"] {
                width:75px;
            }
            canvas {
                margin: 5px;
            }
        </style>
    </head>
    <body>
        <a href="."><b>Flat is Justice - Home</b></a><br>
        <br>
        /start API (ingame): <br><textarea id="start">svdata={"api_result":1,"api_result_msg":"\u6210\u529f","api_data":{"api_cell_data":[{"api_id":3012,"api_no":0,"api_color_no":0,"api_passed":0},{"api_id":3013,"api_no":1,"api_color_no":4,"api_passed":0},{"api_id":3014,"api_no":2,"api_color_no":4,"api_passed":0},{"api_id":3015,"api_no":3,"api_color_no":4,"api_passed":0},{"api_id":3016,"api_no":4,"api_color_no":2,"api_passed":0},{"api_id":3017,"api_no":5,"api_color_no":4,"api_passed":0},{"api_id":3018,"api_no":6,"api_color_no":4,"api_passed":0},{"api_id":3019,"api_no":7,"api_color_no":2,"api_passed":0},{"api_id":3020,"api_no":8,"api_color_no":3,"api_passed":0},{"api_id":3021,"api_no":9,"api_color_no":4,"api_passed":0},{"api_id":3022,"api_no":10,"api_color_no":5,"api_passed":0},{"api_id":3023,"api_no":11,"api_color_no":4,"api_passed":0},{"api_id":3024,"api_no":12,"api_color_no":4,"api_passed":0},{"api_id":3025,"api_no":13,"api_color_no":5,"api_passed":0}],"api_rashin_flg":1,"api_rashin_id":4,"api_maparea_id":1,"api_mapinfo_no":3,"api_no":3,"api_color_no":4,"api_event_id":4,"api_event_kind":1,"api_next":1,"api_bosscell_no":10,"api_bosscomp":0,"api_airsearch":{"api_plane_type":0,"api_result":0},"api_from_no":0}}
        </textarea><br>
        <div id="startinfo"><b>API info for another map!</b><br>
                    Bypass? <input onchange="update()" type="checkbox" id="bypass"><br></div>
        Map: <input type="text" id="mapid" value="5-2" onchange="update()"> 
        <!--<button name="tsunCollect" onclick="tsunDB(document.getElementById('mapid').value)">Get from TsunDB</button>--><br><br>
        Show routing edges <input onchange="update()" type="checkbox" id="routeedges"><br>
        Show to edge ids <input onchange="update()" type="checkbox" id="toEdges"><br>
        Show cleared path <input onchange="update()" type="checkbox" id="cleared" checked><br>
        Guess letters <input onchange="update()" type="checkbox" id="guessLetters"><br>
        Show API info <input onchange="update()" type="checkbox" id="apiinfo"><br>
        Show LBAS range <input onchange="update()" type="checkbox" id="distance" checked><br>
        Show colors (of api when entered) <input onchange="update()" type="checkbox" id="colors" checked><br>
        Show color of offset tag <input onchange="update()" type="checkbox" id="offsetColored" checked><br>
        <br>
        <button name="Update" onclick="update()">Force update</button><br><br>
        <a id="download">Download</a><br>
        <b>Edges map</b><br>
        <script type="text/javascript">
            var show = {}, locData, mapKey, svdata, bypass, wrongmap, canvas;

            let app = new PIXI.Application({width: 1200, height: 720, transparent: true, forceCanvas: true, preserveDrawingBuffer:true});
            document.body.appendChild(canvas = app.view);
            function update(map = document.getElementById("mapid").value, callback) {
                document.getElementById("mapid").value = map;
                for (var i = app.stage.children.length - 1; i >= 0; i--) {  app.stage.removeChild(app.stage.children[i]);};

                eval((document.getElementById("start").value || "") == "" ? "svdata={}" : document.getElementById("start").value);
                show.routeedges = document.getElementById("routeedges").checked;
                show.toEdges = document.getElementById("toEdges").checked;
                show.cleared = document.getElementById("cleared").checked;
                show.guessLetters = document.getElementById("guessLetters").checked;
                show.apiinfo = document.getElementById("apiinfo").checked;
                show.distance = document.getElementById("distance").checked;
                show.colors = document.getElementById("colors").checked;
                show.offsetColored = document.getElementById("offsetColored").checked; 

                map = map.split("-").map((a) => parseInt(a));

                if(svdata && !(correctmap = (svdata.api_data.api_maparea_id == map[0] && svdata.api_data.api_mapinfo_no == map[1]))) {
                    document.getElementById("startinfo").style = "";
                    bypass = document.getElementById("bypass").checked;
                } else 
                    document.getElementById("startinfo").style = "display:none;";

                document.getElementById("apiinfo").disabled = !(correctmap || bypass);
                document.getElementById("distance").disabled = !(correctmap || bypass);

                let imageUrl = `http://203.104.209.23/kcs2/resources/map/${pad(map[0], 3)}/${pad(map[1], 2)}_image.json`;
                let spotsUrl = `http://203.104.209.23/kcs2/resources/map/${pad(map[0], 3)}/${pad(map[1], 2)}_info.json`;
                mapKey = `map${pad(map[0], 3)}${pad(map[1], 2)}_`
                //console.log(imageUrl)

                let loader = new PIXI.loaders.Loader;
                let bgLayer = new PIXI.Container;

                loader.add(imageUrl).add('http://203.104.209.23/kcs2/img/map/map_common.json').load(function() {
                    getJSON(spotsUrl, function (info) {
                        locData = info;
                        for (let bg of info.bg) {
                            let frame = PIXI.Texture.fromFrame(mapKey + bg);
                            let sprite = new PIXI.Sprite(frame);
                            bgLayer.addChild(sprite);
                        }
                        drawEdgesOnGraph(callback)
                    });
                })
                app.stage.addChild(bgLayer);
            }
            function getNodeInfo(id) {
                return locData.spots[id]; //.find((n) => n.no == id)
            }
            function colorToTexture(colorid) {
                // .prototype._getTexture
                switch(colorid) {
                    case -1:
                        return 'map_common_132';
                    case 1:
                        return 'map_common_125';
                    case 2:
                    case 6:
                        return 'map_common_128';
                    case 3:
                        return 'map_common_130';
                    case 4:
                        return 'map_common_131';
                    case 5:
                        return 'map_common_120';
                    case 7:
                        return 'map_common_100';
                    case 8:
                        return 'map_common_119';
                    case 9:
                        return 'map_common_129';
                    case 10:
                        return 'map_common_95';
                    case 11:
                        return 'map_common_133';
                    case 12:
                        return 'map_common_134';
                    case -2:
                        return 'map_common_127'
                    }
            }
            function drawEnds(edgeData) {
                let highestEdge = Math.max(...locData.spots.map((n) => n.no));

                //console.log(highestEdge);
                let wikiaCoordinates = ``, doneWikiaLetters = [];
                for(let id in locData.spots) {
                    let nodeInfo = getNodeInfo(id);
                    let {x,y} = nodeInfo;

                    let msg = "Start";
                    if(edgeData[id])
                        msg = edgeData[id][1];
                    console.log(id, x, y,msg)
                    let text = new PIXI.Text(msg, bigStyle)
                    text.anchor.set(.5,.5)
                    app.stage.addChild(text);
                    text.position.set(x + 30,y - 30);
                    if(doneWikiaLetters.indexOf(msg) >= 0) continue;
                    doneWikiaLetters.push(msg);
                    wikiaCoordinates += `{{Map/ImageNode|${msg}|x=${Math.round(x*700/1200)}|y=${Math.round(y*700/1200)}}}\n`
                }
                console.log(wikiaCoordinates)
            }
            kc3Edges = {};

            let smallStyle = new PIXI.TextStyle({
              fontFamily: "Arial",
              fontSize: 16,
              fill: "white",
              stroke: '#ff3300',
              strokeThickness: 3
            });
            let medStyle = new PIXI.TextStyle({
              fontFamily: "Arial",
              fontSize: 18,
              fill: "white",
              stroke: '#ff3300',
              strokeThickness: 4,
              dropShadow: true,
              dropShadowColor: "#000000",
              dropShadowBlur: 4,
              dropShadowAngle: Math.PI / 6,
              dropShadowDistance: 6,
            });
            let bigStyle = new PIXI.TextStyle({
              fontFamily: "Arial",
              fontSize: 36,
              fill: "white",
              stroke: '#ff3300',
              strokeThickness: 4,
              dropShadow: true,
              dropShadowColor: "#000000",
              dropShadowBlur: 4,
              dropShadowAngle: Math.PI / 6,
              dropShadowDistance: 6,
            });
            function drawEdgesOnGraph(callback) {

                let edges = {};
                for (let edge of locData.spots)
                    if(edges[edge.x + ";" + edge.y])
                        edges[edge.x + ";" + edge.y].push(edge);
                    else
                        edges[edge.x + ";" + edge.y] = [edge];
                kc3Edges = {};
                if(show.colors)
                    for (let edge of Object.values(edges)) {
                        let nodeInfo = edge[0];
                        if(correctmap || bypass)
                            nodeInfo.color = svdata.api_data.api_cell_data[nodeInfo.no].api_color_no;
                        if(nodeInfo.color) {
                            if(show.offsetColored && nodeInfo.offsets)
                                nodeInfo.color = parseInt(Object.keys(nodeInfo.offsets)[0]);
                            else if (show.offsetColored) 
                                nodeInfo.color = 10;
                            console.log(nodeInfo.color)
                            let frame = PIXI.Texture.fromFrame(colorToTexture(nodeInfo.color));
                            let sprite = new PIXI.Sprite(frame);
                            let offsetX = 0, offsetY = 0;
                            if(nodeInfo.color == 5)
                                offsetY = -5;
                            if(nodeInfo.offsets && nodeInfo.offsets[nodeInfo.color]) {
                                offsetX = nodeInfo.offsets[nodeInfo.color].x;
                                offsetY = nodeInfo.offsets[nodeInfo.color].y;
                            }
                            sprite.anchor.set(.5,.5)
                            sprite.position.set(nodeInfo.x + offsetX, nodeInfo.y + offsetY);
                            app.stage.addChild(sprite);
                        }
                    }

                for(let nodeInfo of locData.spots) {
                    let id = nodeInfo.no;

                    if(!nodeInfo.line) continue;

                    let frame = PIXI.Texture.fromFrame(mapKey + (nodeInfo.line.img || ("route_" + id)))
                    let sprite = new PIXI.Sprite(frame);
                    sprite.position.set(nodeInfo.x + nodeInfo.line.x, nodeInfo.y + nodeInfo.line.y);
                    if(show.cleared)
                        app.stage.addChild(sprite);

                    let bounds = sprite.getBounds();
                    //console.log(id, nodeInfo, bounds)
                    let middlex = bounds.x + bounds.width/2;
                    let middley = bounds.y + bounds.height/2;
                    let x = bounds.x + bounds.width;
                    let y = bounds.y + bounds.height;
                    if(nodeInfo.line.x < 0)
                        x += nodeInfo.line.x; 
                    if(nodeInfo.line.y < 0)
                        y += nodeInfo.line.y;

                    if(show.routeedges) {
                        let text = new PIXI.Text(id, medStyle)
                        text.anchor.set(.5,.5)
                        app.stage.addChild(text);
                        text.position.set(middlex, middley);
                    }

                    let closestFrom = nodeInfo;
                    for (let node of locData.spots)
                        if ((node.x-x)**2 + (node.y-y)**2 < (closestFrom.x-x)**2 + (closestFrom.y-y)**2)
                            closestFrom = node;

                    let fromId = "Node" + edges[closestFrom.x + ";" + closestFrom.y].map((e) => e.no).join("_");
                    let toId = "Node" + edges[nodeInfo.x + ";" + nodeInfo.y].map((e) => e.no).join("_");

                    if(show.guessLetters) {
                        if(edges[closestFrom.x + ";" + closestFrom.y][0].no == 0)
                            fromId = "Start";
                        else
                            fromId = "?ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[edges[closestFrom.x + ";" + closestFrom.y][0].no]
                        if(edges[nodeInfo.x + ";" + nodeInfo.y][0].no == 0)
                            toId = "Start";
                        else
                            toId = "?ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[edges[nodeInfo.x + ";" + nodeInfo.y][0].no]
                    }
                    kc3Edges[id] = [fromId, toId];
                }

                if(show.toEdges)
                    for (let edge of Object.values(edges)) {
                        let ids = edge.map((e) => e.no).join(", ");

                        let {x, y} = edge[0]
                        let text = new PIXI.Text(ids, smallStyle);
                        text.anchor.set(.5,.5);
                        app.stage.addChild(text);
                        text.position.set(x,y)
                    }
                if(show.apiinfo && (correctmap || bypass))
                    for (let edge of Object.values(edges)) {
                        let info = edge.map(function (e) {
                            let d = svdata.api_data.api_cell_data.find((m) => m.api_no == e.no);
                            return `${e.no}: c: ${d.api_color_no} r:${d.api_distance}`
                        }).join(", ");

                        let {x, y} = edge[0]
                        let text = new PIXI.Text(info, smallStyle);
                        text.anchor.set(.5,.5);
                        app.stage.addChild(text);
                        text.position.set(x, y + 30)
                    }

                if(show.distance && svdata && svdata.api_data && svdata.api_data.api_cell_data && (correctmap || bypass))
                    for (let edge of Object.values(edges)) {
                        let distance = unique(edge.map((e) => svdata.api_data.api_cell_data.find((m) => m.api_no == e.no).api_distance)).join("/");
                        let {x, y} = edge[0];
                        let text = new PIXI.Text(distance, bigStyle);
                        text.anchor.set(.5,.5);
                        app.stage.addChild(text);
                        text.position.set(x, y)
                    }
                if(show.guessLetters)
                    drawEnds(kc3Edges);

                console.log(`"World ${document.getElementById("mapid").value}" : {\n${Object.keys(kc3Edges).map((k) => `      "${k}" : ["${kc3Edges[k][0]}", "${kc3Edges[k][1]}"]`).join(",\n")}\n    },`)
                document.getElementById("download").href = "";
                setTimeout(() =>
                    blobUtil.canvasToBlob(canvas, 'image/png').then(function (blob) {
                        console.log(blob.size)
                        document.getElementById("download").href = blobUtil.createObjectURL(blob);
                    }), 100);
                document.getElementById("download").addEventListener('click', function() {
                    let d = new Date();
                    this.download = `Map ${document.getElementById("mapid").value}.png`;
                }, false);

                if(callback) callback();
            }

            function pad(n, width = 3, z = '0') {
                n = n + '';
                return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
            }
            function getJSON(url, callback) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.responseType = 'json';
                xhr.onload = function() {
                    var status = xhr.status;
                    if (status === 200) {
                        callback(xhr.response);
                    } else {
                        alert("Error with request " + url + ": " + status);
                    }
                };
                xhr.send();
            };
            function tsunDB(map) {
                getJSON(`http://kckai.cybersnets.com/api/routes/data/${map}?offset=0&limit=1&next_route=0`, function(data){
                    document.getElementById("start").value = "svdata=" + JSON.stringify({api_data: { api_cell_data: data[0].mapNodes } });
                });
            }

            function unique(arr) {
                return arr.reduce(function(accum, current) {
                    if (accum.indexOf(current) < 0) {
                        accum.push(current);
                    }
                    return accum;
                }, []);
            }

            function colorCodes() {
                document.getElementById("start").value = 'svdata={"api_result":1,"api_result_msg":"成功","api_data":{"api_cell_data":[{"api_no":0,"api_event_id":0,"api_event_kind":0},{"api_no":1,"api_event_id":6,"api_event_kind":2,"api_distance":1},{"api_no":2,"api_event_id":6,"api_event_kind":0,"api_distance":1},{"api_no":3,"api_event_id":2,"api_event_kind":0,"api_distance":2},{"api_no":4,"api_event_id":3,"api_event_kind":0,"api_distance":3},{"api_no":5,"api_event_id":7,"api_event_kind":0,"api_distance":3},{"api_no":6,"api_event_id":8,"api_event_kind":0,"api_distance":2},{"api_no":7,"api_event_id":9,"api_event_kind":0,"api_distance":4},{"api_no":8,"api_event_id":4,"api_event_kind":2,"api_distance":4},{"api_no":9,"api_event_id":4,"api_event_kind":7,"api_distance":3},{"api_no":10,"api_event_id":4,"api_event_kind":4,"api_distance":4},{"api_no":11,"api_event_id":4,"api_event_kind":5,"api_distance":5},{"api_no":12,"api_event_id":4,"api_event_kind":6,"api_distance":5},{"api_no":13,"api_event_id":4,"api_event_kind":1,"api_distance":5},{"api_no":14,"api_event_id":5,"api_event_kind":1,"api_distance":2}]}}';
                document.getElementById("swf").value = ``
                document.getElementById("url").value = "https://i.imgur.com/dKIrqI1.png";
                update();
            }
            update();
        </script>
    </body>
</html>