<!doctype html>
<html>
    <head>
        <title>Flat is Justice! - lbas range map maker</title>
        <meta name="theme-color" content="#082E6B"/>
        <meta name=viewport content="width=device-width, initial-scale=1">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Flat is Justice - lbas range map maker">
        <meta name="twitter:description" content="Make LBAS range maps">
        <meta name="twitter:image" content="http://flatisjustice.moe/pics/lbasrangemapmaker.png">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.1/pixi.min.js"></script>
        <script src="https://unpkg.com/blob-util/dist/blob-util.min.js"></script>

        <style type="text/css">
            input[type="number"] {
                width:75px;
            }
            canvas {
                margin: 5px;
            }
        </style>
    </head>
    <body>
        <a href="."><b>Flat is Justice - Home</b></a><br>
        <br>
        /start API (ingame): <br><textarea id="start">svdata={"api_result":1,"api_result_msg":"\u6210\u529f","api_data":{"api_cell_data":[{"api_id":3012,"api_no":0,"api_color_no":0,"api_passed":0},{"api_id":3013,"api_no":1,"api_color_no":4,"api_passed":0},{"api_id":3014,"api_no":2,"api_color_no":4,"api_passed":0},{"api_id":3015,"api_no":3,"api_color_no":4,"api_passed":0},{"api_id":3016,"api_no":4,"api_color_no":2,"api_passed":0},{"api_id":3017,"api_no":5,"api_color_no":4,"api_passed":0},{"api_id":3018,"api_no":6,"api_color_no":4,"api_passed":0},{"api_id":3019,"api_no":7,"api_color_no":2,"api_passed":0},{"api_id":3020,"api_no":8,"api_color_no":3,"api_passed":0},{"api_id":3021,"api_no":9,"api_color_no":4,"api_passed":0},{"api_id":3022,"api_no":10,"api_color_no":5,"api_passed":0},{"api_id":3023,"api_no":11,"api_color_no":4,"api_passed":0},{"api_id":3024,"api_no":12,"api_color_no":4,"api_passed":0},{"api_id":3025,"api_no":13,"api_color_no":5,"api_passed":0}],"api_rashin_flg":1,"api_rashin_id":4,"api_maparea_id":1,"api_mapinfo_no":3,"api_no":3,"api_color_no":4,"api_event_id":4,"api_event_kind":1,"api_next":1,"api_bosscell_no":10,"api_bosscomp":0,"api_airsearch":{"api_plane_type":0,"api_result":0},"api_from_no":0}}
        </textarea><br>
        <div id="startinfo"><b>API info for another map!</b><br>
                    Bypass? <input onchange="update()" type="checkbox" id="bypass"><br></div>
        Map: <input type="text" id="mapid" value="5-2" onchange="update()"> 
        <!--<button name="tsunCollect" onclick="tsunDB(document.getElementById('mapid').value)">Get from TsunDB</button>--><br><br>
        Show routing edges <input onchange="update()" type="checkbox" id="routeedges"><br>
        Show to edge ids <input onchange="update()" type="checkbox" id="toEdges"><br>
        Show cleared path <input onchange="update()" type="checkbox" id="cleared" checked><br>
        Guess letters <input onchange="update()" type="checkbox" id="guessLetters"><br>
        Show API info <input onchange="update()" type="checkbox" id="apiinfo"><br>
        Show LBAS range <input onchange="update()" type="checkbox" id="distance" checked><br>
        Show colors (of api when entered) <input onchange="update()" type="checkbox" id="colors" checked><br>
        Show color of offset tag <input onchange="update()" type="checkbox" id="offsetColored" checked><br>
        Show enemies <input onchange="update()" type="checkbox" id="enemies" checked><br>
        Show gauge <input type="number" id="gauge" min="-1" max="20" onchange="update();" value="-1">
        <div id="gaugeinfo"></div>
        Show hidden routes [UNTESTED] <input type="number" id="hiddenRoutes" min="0" max="20" onchange="update();" value="0">
        <div id="hiddenrouteinfo"></div>
        <br>
        <button name="Update" onclick="update()">Force update</button><br><br>
        <a id="download">Download</a><br>
        <b>Edges map</b><br>
        <script type="text/javascript">
            var show = {}, locData, mapKey, svdata, bypass, wrongmap, canvas, bgLayer, loader, map, gaugeData;
            let SERVER = "203.104.209.71";
            let GAUGE_ROOT = `http://${SERVER}/kcs2/resources/gauge/`;

            let app = new PIXI.Application({width: 1200, height: 720, transparent: true, forceCanvas: true, preserveDrawingBuffer:true});
            document.body.appendChild(canvas = app.view);
            function update(selectedmap = document.getElementById("mapid").value) {
                document.getElementById("mapid").value = selectedmap;
                for (var i = app.stage.children.length - 1; i >= 0; i--) {  app.stage.removeChild(app.stage.children[i]);};

                eval((document.getElementById("start").value || "") == "" ? "svdata={}" : document.getElementById("start").value);
                show.routeedges = document.getElementById("routeedges").checked;
                show.toEdges = document.getElementById("toEdges").checked;
                show.cleared = document.getElementById("cleared").checked;
                show.guessLetters = document.getElementById("guessLetters").checked;
                show.apiinfo = document.getElementById("apiinfo").checked;
                show.distance = document.getElementById("distance").checked;
                show.colors = document.getElementById("colors").checked;
                show.offsetColored = document.getElementById("offsetColored").checked; 
                show.enemies = document.getElementById("enemies").checked; 
                show.hiddenRoutes = parseInt(document.getElementById("hiddenRoutes").value); 
                show.gauge = parseInt(document.getElementById("gauge").value);

                gaugeData = undefined;
                map = selectedmap.split("-").map((a) => parseInt(a));

                if(svdata && !(correctmap = (svdata.api_data.api_maparea_id == map[0] && svdata.api_data.api_mapinfo_no == map[1]))) {
                    document.getElementById("startinfo").style = "";
                    bypass = document.getElementById("bypass").checked;
                } else 
                    document.getElementById("startinfo").style = "display:none;";

                document.getElementById("apiinfo").disabled = !(correctmap || bypass);
                document.getElementById("distance").disabled = !(correctmap || bypass);

                let mapname = `${pad(map[0], 3)}${pad(map[1], 2)}`;
                mapKey = `map${mapname}_`
                //console.log(imageUrl)

                loader = new PIXI.loaders.Loader;
                bgLayer = new PIXI.Container;

                loader.add(getPath('image.json')).add(`http://${SERVER}/kcs2/img/map/map_common.json`).load(function() {
                    getJSON(getPath('info.json'), function (info) {
                        locData = info;
                        let callback = function() {
                            if(show.gauge != -1)
                                getJSON(GAUGE_ROOT + mapname + (show.gauge?("_"+show.gauge):"") + ".json", function (info) {
                                    gaugeData = info;
                                    if(gaugeData && gaugeData.vertical && gaugeData.vertical.img) {
                                        if(!gaugeData.vertical.img_l)
                                            gaugeData.vertical.img_l = gaugeData.vertical.img + "_light"
                                        loader.add(gaugeData.vertical.img, GAUGE_ROOT + gaugeData.vertical.img + ".png")
                                              .add(gaugeData.vertical.img_l, GAUGE_ROOT + gaugeData.vertical.img_l + ".png").load(function() {
                                            if(locData)
                                                showMap();
                                        })
                                    }
                                }, function (err) {
                                    document.getElementById("gaugeinfo").innerHTML = `No gauge with id ${show.gauge} found!`
                                });
                        }
                        if(show.hiddenRoutes) {
                            getAddingInfo(0, callback);
                            showMap();
                        } else 
                            showMap(callback);
                    });
                })

                document.getElementById("hiddenrouteinfo").innerHTML = "";
                document.getElementById("gaugeinfo").innerHTML = "";
                app.stage.addChild(bgLayer);
            }
            function getPath(url) {
                return `http://${SERVER}/kcs2/resources/map/${pad(map[0], 3)}/${pad(map[1], 2)}_${url}`
            }
            function getAddingInfo(depth, callback) {
                document.getElementById("hiddenrouteinfo").innerHTML = `Searching ${depth+1} deep...`;
                getJSON(getPath(`info${locData.spots.length}.json`), function (info) {
                    document.getElementById("hiddenrouteinfo").innerHTML = `Found ${depth} hidden node unlocks, loading spritesheet...`;
                    loader.add(getPath(`image${locData.spots.length}.json`)).load(function() {
                        document.getElementById("hiddenrouteinfo").innerHTML = `Found ${depth} hidden node unlocks, rendering`;
                        if(locData.bg)
                            for(let background of info.bg)
                                locData.bg.push(background);
                        else locData.bg = spots.bg;

                        if(locData.spots) 
                            for(let spot of info.spots)
                                info.spots.push(spot);
                        else locData.spots = info.spots;

                        if(locData.enemies) 
                            for(let enemy of info.enemies)
                                locData.enemies.push(enemy);
                        else locData.enemies = info.enemies;

                        showMap();
                        depth++;
                        if(depth < show.hiddenRoutes) {
                            document.getElementById("hiddenrouteinfo").innerHTML = `Found ${depth} hidden node unlocks, reached max depth ${show.hiddenRoutes}`;
                            if(callback) callback();
                        } else
                            getAddingInfo(depth, callback);
                    })
                }, function (err) {
                    console.log("No more hidden routes");
                    document.getElementById("hiddenrouteinfo").innerHTML = `Found ${depth} hidden node unlocks, no more on servers`;
                })
            }
            function showMap(callback) {
                for (let bg of locData.bg) {
                    let frame = PIXI.Texture.fromFrame(mapKey + bg);
                    let sprite = new PIXI.Sprite(frame);
                    bgLayer.addChild(sprite);
                }
                drawEdgesOnGraph(callback);
            }
            function getNodeInfo(id) {
                return locData.spots[id]; //.find((n) => n.no == id)
            }
            function colorToTexture(colorid) {
                // .prototype._getTexture
                switch(colorid) {
                    case -1:
                        return 'map_common_132';
                    case 1:
                        return 'map_common_125';
                    case 2:
                    case 6:
                        return 'map_common_128';
                    case 3:
                        return 'map_common_130';
                    case 4:
                        return 'map_common_131';
                    case 5:
                        return 'map_common_120';
                    case 7:
                        return 'map_common_100';
                    case 8:
                        return 'map_common_119';
                    case 9:
                        return 'map_common_129';
                    case 10:
                        return 'map_common_95';
                    case 11:
                        return 'map_common_133';
                    case 12:
                        return 'map_common_134';
                    case -2:
                        return 'map_common_127'
                    }
            }
            function drawEnds(edgeData) {
                let highestEdge = Math.max(...locData.spots.map((n) => n.no));

                //console.log(highestEdge);
                let wikiaCoordinates = ``, doneWikiaLetters = [];
                for(let id in locData.spots) {
                    let nodeInfo = getNodeInfo(id);
                    let {x,y} = nodeInfo;

                    let msg = "Start";
                    if(edgeData[id])
                        msg = edgeData[id][1];
                    console.log(id, x, y,msg)
                    let text = new PIXI.Text(msg, bigStyle)
                    text.anchor.set(.5,.5)
                    app.stage.addChild(text);
                    text.position.set(x + 30,y - 30);
                    if(doneWikiaLetters.indexOf(msg) >= 0) continue;
                    doneWikiaLetters.push(msg);
                    wikiaCoordinates += `{{Map/ImageNode|${msg}|x=${Math.round(x*700/1200)}|y=${Math.round(y*700/1200)}}}\n`
                }
                console.log(wikiaCoordinates)
            }
            kc3Edges = {};

            let smallStyle = new PIXI.TextStyle({
              fontFamily: "Arial",
              fontSize: 16,
              fill: "white",
              stroke: '#ff3300',
              strokeThickness: 3
            });
            let medStyle = new PIXI.TextStyle({
              fontFamily: "Arial",
              fontSize: 18,
              fill: "white",
              stroke: '#ff3300',
              strokeThickness: 4,
              dropShadow: true,
              dropShadowColor: "#000000",
              dropShadowBlur: 4,
              dropShadowAngle: Math.PI / 6,
              dropShadowDistance: 6,
            });
            let bigStyle = new PIXI.TextStyle({
              fontFamily: "Arial",
              fontSize: 36,
              fill: "white",
              stroke: '#ff3300',
              strokeThickness: 4,
              dropShadow: true,
              dropShadowColor: "#000000",
              dropShadowBlur: 4,
              dropShadowAngle: Math.PI / 6,
              dropShadowDistance: 6,
            });
            let lbasStyle = new PIXI.TextStyle({
              fontFamily: "Arial",
              fontSize: 36,
              fill: "#00ff00",
              stroke: '#006600',
              strokeThickness: 3,
              dropShadow: true,
              dropShadowColor: "#001100",
              dropShadowBlur: 4,
              dropShadowAngle: Math.PI / 6,
              dropShadowDistance: 4,
            });
            function drawEdgesOnGraph(callback) {
                let edges = {};
                for (let edge of locData.spots)
                    if(edges[edge.x + ";" + edge.y])
                        edges[edge.x + ";" + edge.y].push(edge);
                    else
                        edges[edge.x + ";" + edge.y] = [edge];
                kc3Edges = {};
                if(show.colors)
                    for (let edge of Object.values(edges)) {
                        let nodeInfo = edge[0];
                        if(correctmap || bypass)
                            nodeInfo.color = svdata.api_data.api_cell_data[nodeInfo.no].api_color_no;
                        if(nodeInfo.color) {
                            if(show.offsetColored && nodeInfo.offsets)
                                nodeInfo.color = parseInt(Object.keys(nodeInfo.offsets)[0]);
                            console.log(nodeInfo.color)
                            let frame = PIXI.Texture.fromFrame(colorToTexture(nodeInfo.color));
                            let sprite = new PIXI.Sprite(frame);
                            let offsetX = 0, offsetY = 0;
                            if(nodeInfo.color == 5)
                                offsetY = -5;
                            if(nodeInfo.offsets && nodeInfo.offsets[nodeInfo.color]) {
                                offsetX = nodeInfo.offsets[nodeInfo.color].x;
                                offsetY = nodeInfo.offsets[nodeInfo.color].y;
                            }
                            sprite.anchor.set(.5,.5)
                            sprite.position.set(nodeInfo.x + offsetX, nodeInfo.y + offsetY);
                            app.stage.addChild(sprite);
                        }
                    }

                for(let nodeInfo of locData.spots) {
                    let id = nodeInfo.no;

                    if(!nodeInfo.line) continue;

                    let frame = PIXI.Texture.fromFrame(mapKey + (nodeInfo.line.img || ("route_" + id)))
                    let sprite = new PIXI.Sprite(frame);
                    sprite.position.set(nodeInfo.x + nodeInfo.line.x, nodeInfo.y + nodeInfo.line.y);
                    if(show.cleared)
                        app.stage.addChild(sprite);

                    let bounds = sprite.getBounds();
                    //console.log(id, nodeInfo, bounds)
                    let middlex = bounds.x + bounds.width/2;
                    let middley = bounds.y + bounds.height/2;
                    let x = bounds.x + bounds.width;
                    let y = bounds.y + bounds.height;
                    if(nodeInfo.line.x < 0)
                        x += nodeInfo.line.x; 
                    if(nodeInfo.line.y < 0)
                        y += nodeInfo.line.y;

                    if(show.routeedges) {
                        let text = new PIXI.Text(id, medStyle)
                        text.anchor.set(.5,.5)
                        app.stage.addChild(text);
                        text.position.set(middlex, middley);
                    }

                    let closestFrom = nodeInfo;
                    for (let node of locData.spots)
                        if ((node.x-x)**2 + (node.y-y)**2 < (closestFrom.x-x)**2 + (closestFrom.y-y)**2)
                            closestFrom = node;

                    let fromId = "Node" + edges[closestFrom.x + ";" + closestFrom.y].map((e) => e.no).join("_");
                    let toId = "Node" + edges[nodeInfo.x + ";" + nodeInfo.y].map((e) => e.no).join("_");

                    if(show.guessLetters) {
                        if(edges[closestFrom.x + ";" + closestFrom.y][0].no == 0)
                            fromId = "Start";
                        else
                            fromId = "?ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[edges[closestFrom.x + ";" + closestFrom.y][0].no]
                        if(edges[nodeInfo.x + ";" + nodeInfo.y][0].no == 0)
                            toId = "Start";
                        else
                            toId = "?ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[edges[nodeInfo.x + ";" + nodeInfo.y][0].no]
                    }
                    kc3Edges[id] = [fromId, toId];
                }

                if(show.gauge != -1 && gaugeData) {
                    if(gaugeData.vertical.bar) {
                        let colorbox = new PIXI.Graphics;
                        colorbox.beginFill(gaugeData.vertical.bar.color || 16711680);
                        let barH = gaugeData.vertical.bar.h || 219
                        let barW = gaugeData.vertical.bar.w || 14

                        colorbox.drawRect(gaugeData.vertical.x + gaugeData.vertical.bar.x, gaugeData.vertical.y + gaugeData.vertical.bar.y, barW, barH);
                        colorbox.endFill()
                        app.stage.addChild(colorbox);
                    }
                    let frame = PIXI.Texture.fromFrame(gaugeData.vertical.img)
                    let sprite = new PIXI.Sprite(frame);
                    sprite.position.set(gaugeData.vertical.x, gaugeData.vertical.y);
                    app.stage.addChild(sprite);


                    frame = PIXI.Texture.fromFrame(gaugeData.vertical.img_l)
                    sprite = new PIXI.Sprite(frame);
                    let lightoffset = gaugeData.vertical.light ? gaugeData.vertical.light : {x:0,y:0}
                    sprite.position.set(gaugeData.vertical.x + lightoffset.x, gaugeData.vertical.y + lightoffset.y);
                    app.stage.addChild(sprite);
                }

                if(show.enemies && locData.enemies) {
                    for(let enemy of locData.enemies) {
                        let frame = PIXI.Texture.fromFrame(mapKey + enemy.img)
                        let sprite = new PIXI.Sprite(frame);
                        sprite.position.set(enemy.x, enemy.y);
                        app.stage.addChild(sprite);
                    }
                }

                if(show.toEdges)
                    for (let edge of Object.values(edges)) {
                        let ids = edge.map((e) => e.no).join(", ");

                        let {x, y} = edge[0]
                        let text = new PIXI.Text(ids, smallStyle);
                        text.anchor.set(.5,.5);
                        app.stage.addChild(text);
                        text.position.set(x,y)
                    }
                if(show.apiinfo && (correctmap || bypass))
                    for (let edge of Object.values(edges)) {
                        let info = edge.map(function (e) {
                            let d = svdata.api_data.api_cell_data.find((m) => m.api_no == e.no);
                            return `${e.no}: c: ${d.api_color_no} r:${d.api_distance}`
                        }).join(", ");

                        let {x, y} = edge[0]
                        let text = new PIXI.Text(info, smallStyle);
                        text.anchor.set(.5,.5);
                        app.stage.addChild(text);
                        text.position.set(x, y + 30)
                    }

                if(show.distance && svdata && svdata.api_data && svdata.api_data.api_cell_data && (correctmap || bypass))
                    for (let edge of Object.values(edges)) {
                        let distance = unique(edge.map((e) => svdata.api_data.api_cell_data.find((m) => m.api_no == e.no).api_distance)).join("/");
                        let {x, y} = edge[0];
                        let text = new PIXI.Text(distance, lbasStyle);
                        text.anchor.set(.5,.5);
                        app.stage.addChild(text);
                        text.position.set(x - 25, y - 30)
                    }
                if(show.guessLetters)
                    drawEnds(kc3Edges);

                app.render();
                console.log(`"World ${document.getElementById("mapid").value}" : {\n${Object.keys(kc3Edges).map((k) => `      "${k}" : ["${kc3Edges[k][0]}", "${kc3Edges[k][1]}"]`).join(",\n")}\n    },`)
                delete document.getElementById("download").href 
                blobUtil.canvasToBlob(canvas, 'image/png').then(function (blob) {
                    console.log(blob.size)
                    document.getElementById("download").href = blobUtil.createObjectURL(blob);
                })
                document.getElementById("download").addEventListener('click', function() {
                    let d = new Date();
                    this.download = `Map ${document.getElementById("mapid").value}.png`;
                }, false);

                if(callback) callback();
            }

            function pad(n, width = 3, z = '0') {
                n = n + '';
                return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
            }
            function getJSON(url, callback, errorcallback) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.responseType = 'json';
                xhr.onload = function() {
                    var status = xhr.status;
                    if (status === 200) {
                        callback(xhr.response);
                    } else {
                        if(!errorcallback)
                            alert("Error with request " + url + ": " + status);
                        else 
                            errorcallback(status)
                    }
                };
                xhr.send();
            };
            function tsunDB(map) {
                getJSON(`http://tsundb.kc3.moe/api/routes/data/${map}?offset=0&limit=1&next_route=0`, function(data){
                    document.getElementById("start").value = "svdata=" + JSON.stringify({api_data: { api_cell_data: data[0].mapNodes } });
                });
            }

            function unique(arr) {
                return arr.reduce(function(accum, current) {
                    if (accum.indexOf(current) < 0) {
                        accum.push(current);
                    }
                    return accum;
                }, []);
            }
            update();
        </script>
    </body>
</html>