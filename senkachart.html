<!doctype html>
<html>
    <head>
        <title>Flat is Justice! - Senka Chart</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="theme-color" content="#082E6B"/>
        <meta name=viewport content="width=device-width, initial-scale=1">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Flat is Justice - Senka Chart">
        <meta name="twitter:description" content="Make chart of senka stuff">
        <style type="text/css">
            div {
                display:inline;
            }
            textarea {
                width: 700px;
                height: 200px;
            }
            table > tr > th, table > tr > td, table > * > tr > th, table > * > tr > td {
                border: 1px #aaa solid;
                padding: 0.1em
            }
        </style>
        <script src="https://unpkg.com/blob-util/dist/blob-util.min.js"></script>
    </head>
    <body> 
        <a href="."><b>Flat is Justice - Home</b></a><br>

        Output: Download: <a id='downloadSumTop'>Summary/Top</a> <a id='download'>All</a> <a id='download1'>#1</a> <a id='download5'>#5</a> <a id='download20'>#20</a> <a id='download100'>#100</a> <a id='download500'>#500</a><br><br>

        <label>Finder youselves! Username: <input id="playername" onchange="findUser(this)"></input></label><br>
        <div id="found"></div>

        <br><b>Graphs:</b><br>
        Summary and Top players:<br>
        <canvas id="graphSumTop" width="1446" height="550"></canvas><br>
        All top XXX graphs<br>
        <canvas id="graphOfGraphs" width="1935" height="1640"></canvas><br><br>

        <label>All ranks server (0 = normal): <input type="number" id="server" min="0" max="20" step="1" onchange="update(true);" onclick="update(true);" value="0"><br></label>
        <canvas id="graphMix" width="960" height="540"></canvas><br>
        <br>
        <canvas style="display:none" id="graphSummary" width="705" height="540"></canvas>
        <canvas style="display:none" id="graphTopPlayers" width="726" height="540"></canvas>
        <canvas style="display:none" id="graph1" width="960" height="540"></canvas>
        <canvas style="display:none" id="graph5" width="960" height="540"></canvas>
        <canvas style="display:none" id="graph20" width="960" height="540"></canvas>
        <canvas style="display:none" id="graph100" width="960" height="540"></canvas>
        <canvas style="display:none" id="graph500" width="960" height="540"></canvas>
        <script type="text/javascript">
            var data = {};
            let colors = ["#e6194b", "#3cb44b", "#ffe119", "#0082c8", "#f58231", "#911eb4", "#46f0f0", "#f032e6", "#d2f53c", "#fabebe", "#008080", "#e6beff", "#aa6e28", "#808080", "#800000", "#aaffc3", "#808000", "#ffd8b1", "#000080", "#a873b7"];
            const jp_names = ["横須賀", "呉", "佐世保", "舞鶴", "大湊", "トラック", "リンガ", "ラバウル", "ショートランド", "ブイン", "タウイタウイ", "パラオ", "ブルネイ", "単冠", "幌筵", "宿毛", "鹿屋", "岩川", "佐伯湾", "柱島"];
            const en_names = ["Yokosuka", "Kure", "Sasebo", "Maizuru", "Ominato", "Truk", "Lingga", "Rabaul", "Shortland", "Buin", "Tawi-Tawi", "Palau", "Brunei", "Hitokappu", "Paramushir", "Sukumo", "Kanoya", "Iwagawa", "Saiki Bay", "Hashirajima"];
            const ranks = [500, 100, 20, 5, 1];

            var canvas, width, height, ctx;
            var yOffset = 32, rectSize = 8, xOffset = 34;
            let descW = 330, descH = 150;
            var minTime, maxTime;
            var parsed = {}, maxOfRank = {};
            var longestJP, longestScore;
            let allRanksServer = 0;
            let players = [];

            function update(onlyServerRanks) {
                allRanksServer = parseInt(document.getElementById('server').value);
                // Convert data to another format:
                // parsed[rank][ts][serverId - 1] = points

                for(let i = 1; i <= 20; i++) {
                    if(data[i].code == 1) continue;

                    if(allRanksServer)
                        for(let player of data[i].data.players) {
                            for(let senka of player.senka) {
                                let ts = senka.timestamp;
                                let rank = player.rankno;
                                if(minTime == undefined || ts < minTime) minTime = ts;
                                if(maxTime == undefined || ts > maxTime) maxTime = ts;
                                if(parsed[rank] == undefined) parsed[rank] = {};
                                if(parsed[rank][ts] == undefined) parsed[rank][ts] = [];
                                parsed[rank][ts][i - 1] = senka.senka;
                            }
                        }
                    else
                        for(let cutoff of data[i].data.cutofflist) {
                            let ts = cutoff.timestamp;
                            if(minTime == undefined || ts < minTime) minTime = ts;
                            if(maxTime == undefined || ts > maxTime) maxTime = ts;
                            for(let rank in cutoff.cutoff) {
                                if(parsed[rank] == undefined) parsed[rank] = {};
                                if(parsed[rank][ts] == undefined) parsed[rank][ts] = [];
                                parsed[rank][ts][i - 1] = cutoff.cutoff[rank];
                            }
                        }
                }

                players = [];
                for(let i = 1; i <= 20; i++) {
                    if(data[i].code == 1) continue;
                    players.push(...data[i].data.players.map(function(pl) {
                        pl.server = i;
                        return pl;
                    }));
                }
                players.sort((a, b) => b.curRanking - a.curRanking || a.rankno - b.rankno || a.name - b.name);

                // Second cycle
                parsed[500][1533103200000][2] = 278;
                parsed[500][1533103200000][8] = 237;

                // Not updated
                /*
                parsed[500][maxTime][20-1] = 0;
                parsed[100][maxTime][20-1] = 0;
                parsed[ 20][maxTime][20-1] = 0;
                parsed[  5][maxTime][20-1] = 0;
                parsed[  1][maxTime][20-1] = 0;
                */

                for(let rank of Object.keys(parsed))
                    maxOfRank[rank] = Math.max(...Object.values(parsed[rank]).map((a) => Math.max(...a.filter((b) => b))).filter((b) => b))

                //console.log(parsed, minTime, maxTime, maxOfRank);

                canvas = document.getElementById("graph1");
                ctx = canvas.getContext("2d");
                ctx.font = `100 10px sans-serif`
                longestScore = ctx.measureText(" (88888) ").width;
                ctx.font = `100 10px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`
                // Get some widths of longest names;
                longestJP = [0, 0];
                for(let i = 0; i < 20; i++)
                    longestJP[i%2] = Math.max(longestJP[i%2], ctx.measureText(jp_names[i]).width);

                for(let rank of ranks) {
                    if(onlyServerRanks) continue;
                    canvas = document.getElementById("graph" + rank);
                    width = canvas.width;
                    height = canvas.height;
                    ctx = canvas.getContext("2d");

                    clearScreen(); // Clear screen, setup
                    drawVerticalLines(rank); // Draw vertical lines per cycle
                    drawHorizontalLines(maxOfRank[rank]); // Draw horizontal lines depending on max points
                    drawServerLines(rank); // Draw each server's line
                    drawServerLegend(rank); // Draw servers in legend box
                    drawMisc(); // Draw some other shit
                    drawTitle(`All servers - #${rank}`); // Draw title
                    drawBorder();

                    blobUtil.canvasToBlob(canvas, 'image/png').then(function (blob) {
                        document.getElementById("download" + rank).href = blobUtil.createObjectURL(blob);
                    });
                    document.getElementById("download" + rank).addEventListener('click', function() {
                        let d = new Date();
                        this.download = `Top${rank} @ ${d.getFullYear()}-${("0"+(d.getMonth()+1)).slice(-2)}-${("0" + d.getDate()).slice(-2)}.png`;
                    }, false);
                }

                // Draw mix of servers
                canvas = document.getElementById("graphMix");
                width = canvas.width;
                height = canvas.height;
                ctx = canvas.getContext("2d");

                let maxPoints = maxOfRank[1];
                if(allRanksServer)
                    maxPoints = Math.max(...Object.values(parsed[1]).map((a) => a[allRanksServer - 1]).filter((b) => b));
                // maxPoints = 5000;

                ranks.reverse();
                clearScreen(); // Clear screen, setup
                drawVerticalLines(1); // Draw vertical lines per cycle                
                drawHorizontalLines(maxPoints); // Draw horizontal lines depending on max points
                if(allRanksServer) {
                    rectSize = 5;
                    ctx.lineWidth = 1;
                    for(let rank of Object.keys(maxOfRank).sort((a, b) => b-a))
                        drawServerLines(rank, maxPoints); // Draw each server's line
                } else {
                    for(let rank of ranks)
                        drawServerLines(rank, maxPoints); // Draw each server's line
                    drawServerLegend(-1); // Draw servers in legend box
                }
                drawMisc(); // Draw some other shit
                drawTitle(`All ranks${allRanksServer ? ` - ${jp_names[allRanksServer-1]} - ${en_names[allRanksServer-1]}`:''}`); // Draw title
                drawBorder(); // Draw border
                if(onlyServerRanks) return;

                // Draw summary graph
                canvas = document.getElementById("graphSummary");
                width = canvas.width;
                height = canvas.height;
                ctx = canvas.getContext("2d");
                clearScreen(); // Clear screen, setup
                drawTitle(`Summary`); // Draw title
                drawBorder(); // Draw border
                drawSummary();
                drawMisc(true);

                // Draw top players
                canvas = document.getElementById("graphTopPlayers");
                width = canvas.width;
                height = canvas.height;
                ctx = canvas.getContext("2d");
                clearScreen(); // Clear screen, setup
                drawTitle(`Top Players`); // Draw title
                drawBorder(); // Draw border
                drawTopPlayers();
                drawMisc(true);

                ranks.reverse();

                // All graphs combined
                let totalCanvas = document.getElementById("graphOfGraphs");
                ctx = totalCanvas.getContext("2d");
                let coords = [[0, 0], [1, 0], [0, 1], [1, 1], [0, 2], [1, 2]]

                for(let rank of [...ranks, -1]) {
                    if(rank !== -1) {
                        let canvas = document.getElementById("graph" + rank);
                        ctx.drawImage(canvas, 5+coords[ranks.indexOf(rank)][0] * (canvas.width + 5), 5+coords[ranks.indexOf(rank)][1] * (canvas.height + 5))
                    } else {
                        let canvas = document.getElementById("graphMix");
                        ctx.drawImage(canvas, 5+coords[ranks.length][0] * (canvas.width + 5), 5+coords[ranks.length][1] * (canvas.height + 5))
                    }
                }

                blobUtil.canvasToBlob(totalCanvas, 'image/png').then(function (blob) {
                    document.getElementById("download").href = blobUtil.createObjectURL(blob);
                });
                document.getElementById("download").addEventListener('click', function() {
                    let d = new Date();
                    this.download = `Graph of graphs @ ${d.getFullYear()}-${("0"+(d.getMonth()+1)).slice(-2)}-${("0" + d.getDate()).slice(-2)}.png`;
                }, false);

                let canvasSumTop = document.getElementById("graphSumTop");
                ctx = canvasSumTop.getContext("2d");

                canvas = document.getElementById("graphSummary");
                ctx.drawImage(canvas, 5, 5)
                canvas = document.getElementById("graphTopPlayers");
                ctx.drawImage(canvas, 10 + 705, 5)

                blobUtil.canvasToBlob(canvasSumTop, 'image/png').then(function (blob) {
                    document.getElementById("downloadSumTop").href = blobUtil.createObjectURL(blob);
                });
                document.getElementById("downloadSumTop").addEventListener('click', function() {
                    let d = new Date();
                    this.download = `Summary and Top @ ${d.getFullYear()}-${("0"+(d.getMonth()+1)).slice(-2)}-${("0" + d.getDate()).slice(-2)}.png`;
                }, false);
            }

            function clearScreen() {
                ctx.fillStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.fillRect(0, 0, width - 1, height);
                ctx.lineWidth = 2;
                height -= yOffset; 
                ctx.font = `100 10px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`
            }

            function drawVerticalLines(rank) {
                ctx.fillStyle = "#000";
                ctx.fillRect(0, yOffset, width, 1);
                for(let ts in parsed[rank]) {
                    let xPos = xOffset + (ts - minTime) / (maxTime - minTime) * (width - xOffset);
                    ctx.fillRect(xPos, yOffset, 1, height);

                    let str = timeStr(ts);

                    ctx.save();
                    ctx.translate(xPos, height + yOffset);
                    ctx.rotate(Math.PI/2);
                    ctx.textAlign = "right";
                    ctx.fillText(str, -1, -3);
                    ctx.restore();
                }
            }

            function drawHorizontalLines(maxPoints = 3500) {
                ctx.textAlign = "center"; 
                let rankOff = Math.ceil(maxPoints / 10 / 50) * 50;
                for(let i = rankOff; i < maxPoints; i += rankOff) {
                    let yPos = yOffset + height - (i / maxPoints * height);
                    ctx.fillRect(xOffset, yPos, width, 1);
                    ctx.fillText(i, xOffset / 2, yPos + 3);
                }
            }

            function drawServerLines(rank, maximum) {
                let isAll = true;
                if(!maximum) {
                    maximum = maxOfRank[rank];
                    isAll = false;
                }
                for(let i = 0; i < 20; i++) {
                    if(!isAll) {
                        ctx.strokeStyle = colors[i];
                        ctx.fillStyle = colors[i];
                    } else {
                        if(allRanksServer)
                            ctx.strokeStyle = ctx.fillStyle = "hsl(" + (rank / 500 * 360) + ", 100%, 50%)";
                        else
                            ctx.strokeStyle = ctx.fillStyle = colors[ranks.indexOf(parseInt(rank))];
                        if(i != (allRanksServer - 1) && allRanksServer) continue;
                    }
                    let firstOne = true;

                    for(let ts of Object.keys(parsed[rank]).sort()) {
                        let xPos = xOffset + (ts - minTime) / (maxTime - minTime) * (width - xOffset);
                        let yPos = yOffset + height - (parsed[rank][ts][i] / maximum * height);
                        if(parsed[rank][ts][i] == undefined) continue;
                        ctx.fillRect(xPos - rectSize / 2, yPos - rectSize / 2, rectSize, rectSize)
                        
                        if(firstOne) {
                            ctx.beginPath();
                            ctx.moveTo(xPos, yPos);
                        } else {
                            ctx.lineTo(xPos, yPos);
                        }
                        firstOne = false;
                    }
                    ctx.stroke();
                }
            }

            function drawServerLegend(rank) {
                drawServerLegendBox(rank);
                if(rank == -1)
                    drawRankingLegend();
                else
                    drawServerLegendServers(rank);
            }

            function drawServerLegendBox(rank) {
                ctx.beginPath();
                ctx.fillStyle = "rgba(255, 255, 255, 90%)";
                ctx.strokeStyle = "rgba(0, 0, 0, 90%)";

                if(rank == -1)
                    ctx.rect(xOffset + 5, yOffset + 5, 48, 77);
                else
                    ctx.rect(width - descW - 5, height - descH + yOffset - 7, descW, descH + 2);

                ctx.fill();
                ctx.stroke();
            }

            function drawRankingLegend() {
                ctx.textAlign = "left";
                for(let i = 0; i < ranks.length; i++) {
                    let x = xOffset + 15;
                    let y = yOffset + 10 + i * 15;
                    ctx.fillStyle = colors[i];
                    ctx.fillRect(x - rectSize / 2, y, rectSize, rectSize)
                    ctx.fillStyle = "#000";
                    ctx.fillText("#" + ranks[i], x + rectSize, y + rectSize)
                }
            }

            function drawServerLegendServers(rank){
                for(let i = 0; i < 20; i++) {
                    let x = width - descW + 2 + Math.floor(i%2) * 177;
                    let y = height - descH + yOffset - 3 + Math.floor(i/2) * descH / 10;
                    ctx.fillStyle = colors[i];

                    let currentOffset = longestJP[i%2] + longestScore;
                    ctx.fillRect(x - rectSize / 2, y, rectSize, rectSize);
                    if(data[i + 1].code != 2)
                        ctx.fillStyle = "#f00";
                    else if (parsed[rank][maxTime][i] == undefined)
                        ctx.fillStyle = "#f88";
                    else {
                        let currentServer = parsed[rank][maxTime][i];

                        let score = ` (${currentServer}) `;
                        ctx.textAlign = "center";
                        if(colorServer(parsed[rank][maxTime], currentServer))
                            ctx.font = `700 10px sans-serif`
                        else
                            ctx.font = `100 10px sans-serif`
                        ctx.fillText(score, x + rectSize + currentOffset - longestScore / 2 , y + rectSize);
                        ctx.fillStyle = "#000";
                    }
                    ctx.textAlign = "left";
                    ctx.font = `100 10px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`
                    ctx.fillText(jp_names[i], x + rectSize, y + rectSize)
                    ctx.font = `100 10px sans-serif`
                    ctx.fillText(en_names[i], x + rectSize + currentOffset, y + rectSize)
                }
            }

            function drawMisc(onlyEnd) {
                let txt;
                ctx.fillStyle = "#888";
                ctx.textAlign = "right";
                ctx.font = `100 10px sans-serif`
                txt = "Data: senka.com.ru ";
                ctx.fillText(txt, width, 9);
                txt = "Graph generator: @FlatIsNice ";
                ctx.fillText(txt, width, 19);
                if(onlyEnd)
                    txt = `Timestamp: ${timeStr(maxTime)} `;
                else
                    txt = `Timeframe: ${timeStr(minTime)} ~ ${timeStr(maxTime)} `;
                ctx.fillText(txt, width, 29);
            }

            function drawTitle(txt) {
                ctx.font = `800 16px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`;
                ctx.fillStyle = "#000";
                ctx.textAlign = "center";
                ctx.fillText(txt, width / 2, 20);
            }

            function drawBorder() {              
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.strokeStyle = ctx.fillStyle = "#000";  
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.stroke();
            }

            function drawSummary() {
                ctx.textAlign = 'left';
                let longestNames = [0, 0, 0, 0, 0, 0, 0];
                for(let i = 0; i < 20; i++)
                    longestNames[0] = Math.max(longestNames[0], ctx.measureText(jp_names[i]).width);
                for(let i = 0; i < 20; i++)
                    longestNames[1] = Math.max(longestNames[1], ctx.measureText(en_names[i]).width);

                for(let rankIndex in ranks)
                    longestNames[parseInt(rankIndex) + 2] = 85;
                console.log(longestNames)

                for (let i = -1; i <= 20; i++){
                    let y = yOffset + height / 22 * (i + 1);
                    let x = 3;
                    ctx.fillRect(0, y, width, 1);
                    let liney = y + height / 22 - 4;

                    let serverJP = jp_names[i] || "Average"
                    if(i == -1)
                        serverJP = "Server JP";

                    ctx.font = `800 16px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`;
                    ctx.fillText(serverJP, x, liney);
                    x += longestNames[0] + 5;
                    ctx.fillRect(x, y, 1, height / 22);
                    x += 5;

                    for (let rankIndex in ranks) {
                        let rank = ranks[rankIndex = parseInt(rankIndex)];
                        let score = parsed[rank][maxTime][i] || "-----";
                        let diff = -999;
                        ctx.font = `800 16px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`;

                        if(i == 20)
                            score = Math.round(parsed[rank][maxTime].reduce((a, b) => a+b) / 20);
                        else if(i == -1)
                            score = "Top " + rank;
                        else {
                            if (!colorServer(parsed[rank][maxTime], score))
                                ctx.font = `100 16px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`;
                            if (parsed[rank][maxTime - 43200000][i])
                                diff = score - parsed[rank][maxTime - 43200000][i];
                        }

                        ctx.textAlign = 'center';
                        ctx.fillText(score, x  + longestNames[rankIndex + 2] / 2 - ((diff == -999) ? 0 : 10), liney);
                        x += longestNames[rankIndex + 2] + 5;

                        ctx.fillStyle = "#000";
                        if(diff != -999) {
                            ctx.textAlign = 'right';
                            ctx.font = `100 8px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`;
                            ctx.fillText(`(+${diff})`, x - 2, liney);
                        }

                        ctx.fillRect(x, y, 1, height / 22);
                        x += 5;
                    }

                    ctx.textAlign = 'left';
                    ctx.font = `800 16px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`;
                    let serverEN = en_names[i] || "";
                    if(i == -1)
                        serverEN = "Server EN";

                    ctx.fillText(serverEN, x, liney);
                    x += longestNames[1] + 5;
                    ctx.fillRect(x, y, 1, height / 22);
                    x += 5;
                }
            }

            function drawTopPlayers() {
                ctx.textAlign = 'left';

                let longestNames = [0, 0, 0, 0, 0, 0, 0];
                longestNames[0] = ctx.measureText("#20").width;

                for(let i = 0; i < 20; i++)
                    longestNames[1] = Math.max(longestNames[1], ctx.measureText(jp_names[i]).width);
                for(let i = 0; i < 20; i++)
                    longestNames[2] = Math.max(longestNames[2], ctx.measureText(en_names[i]).width);
                for(let i = 0; i < 20; i++)
                    longestNames[3] = Math.max(longestNames[3], ctx.measureText(players[i].name).width + 10);
                // longestNames[3] = ctx.measureText("WWWWWWWWWWWW").width
                longestNames[4] = Math.max(ctx.measureText("Points").width, ctx.measureText(88888).width);

                for (let i = -1; i < 20; i++){
                    let y = yOffset + height / 21 * (i + 1);
                    let x = 3;
                    ctx.fillRect(0, y, width, 1);
                    let liney = y + height / 21 - 4;

                    ctx.font = `800 16px "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro",Osaka, "メイリオ", Meiryo, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif`;

                    ctx.textAlign = 'center';
                    let index = (i + 1) || "#"
                    ctx.fillText(index, x + longestNames[0]/2, liney);
                    x += longestNames[0] + 5;
                    ctx.fillRect(x, y, 1, height / 21);
                    x += 5;
                    ctx.textAlign = 'left';

                    let player = players[i] || { server: 0, rankno: "#", curRanking: "Points", name: "Name", comment: "Comment"};

                    ctx.fillText(player.name, x, liney);
                    x += longestNames[3] + 5;
                    ctx.fillRect(x, y, 1, height / 21);
                    x += 5;

                    ctx.textAlign = 'center';
                    ctx.fillText(player.curRanking, x + longestNames[4] / 2, liney);
                    x += longestNames[4] + 5;
                    ctx.fillRect(x, y, 1, height / 21);
                    x += 5;

                    ctx.fillText(player.rankno, x + longestNames[0] / 2, liney);
                    x += longestNames[0] + 5;
                    ctx.fillRect(x, y, 1, height / 21);
                    x += 5;
                    ctx.textAlign = 'left';

                    let serverJP = jp_names[player.server - 1] || "Server JP";;
                    ctx.fillText(serverJP, x, liney);
                    x += longestNames[1] + 5;
                    ctx.fillRect(x, y, 1, height / 21);
                    x += 5;

                    let serverEN = en_names[player.server - 1] || "Server EN";

                    ctx.textAlign = 'left';
                    ctx.fillText(serverEN, x, liney);
                    x += longestNames[2] + 5;
                    ctx.fillRect(x, y, 1, height / 21);
                    x += 5;

                    ctx.fillText(player.comment, x, liney);
                }
            }

            function colorServer(ranklist, score) {
                let top = ranklist.filter((a) => a).sort((a,b) => b-a);

                ctx.fillStyle = "#000";
                if(score == top[top.length - 1]) {
                    ctx.fillStyle = "#17e204";
                    return true;
                } else if(score <= top[top.length - 3]) {
                    ctx.fillStyle = "#0fb700";
                } else if (score == top[0]) {
                    ctx.fillStyle = "#e20404";
                    return true;
                } else if (score >= top[2]) {
                    ctx.fillStyle = "#b20000";
                }
                return false;
            }
            function convertTime(ts) {
                let timestampTime = new Date(parseInt(ts));
                return new Date(timestampTime.getTime() + timestampTime.getTimezoneOffset() * 60000 + 9 * 3600000);
            }

            function timeStr(ts) {
                let d = convertTime(ts);
                return `${d.getFullYear()}-${("0"+(d.getMonth()+1)).slice(-2)}-${("0" + d.getDate()).slice(-2)} ${("0" + d.getHours()).slice(-2)}:${("0" + d.getMinutes()).slice(-2)}`
            }

            function findUser(us) {
                let username = us.value;
                let filteredPlayers = players.filter((a) => a.name.toLowerCase().indexOf(username.toLowerCase()) >= 0);
                if(filteredPlayers.length > 100) return;
                let maxRank = Math.max(...Object.keys(parsed));
                let minimumCertain = Math.max(...Object.values(parsed[maxRank]).map((a) => Math.max(...a.filter((b) => b))).filter((b) => b)); // Select highest of max rank
                console.log(minimumCertain);
                let html = `Found ${filteredPlayers.length} player(s) containing '<code>${username}</code>'`
                html += `<table><tbody>
                    <tr>
                        <th>Rank (global*)</th>
                        <th>Username</th>
                        <th>Comment</th>
                        <th>Servername (JP)</th>
                        <th>Servername (EN)</th>
                        <th>Rank (server)</th>
                        <th>Current points</th>
                    </tr>`;
                for (let player of filteredPlayers) {
                    console.log(player);
                    let warn = "";
                    if(player.curRanking < minimumCertain)
                        warn = ` style="color:red"`;
                    html += `
                    <tr>
                        <td${warn}>${players.indexOf(player) + 1}</td>
                        <td>${player.name}</td>
                        <td>${player.comment}</td>
                        <td>${jp_names[player.server - 1]}</td>
                        <td>${en_names[player.server - 1]}</td>
                        <td>${player.rankno}</td>
                        <td>${player.curRanking}</td>
                    </tr>`
                }

                html += `</tbody></table>
                Note: ranking is uncertain after ${minimumCertain} ranking points, these are marked red<br>
                Note2: sorting is ranking points > server rank > name<br>`
                document.getElementById("found").innerHTML = html;
            }

            function get(url, name) {
                var xmlhttp = new XMLHttpRequest();
                xmlhttp.onreadystatechange = function() {
                    if (xmlhttp.readyState == XMLHttpRequest.DONE ) {
                        if (xmlhttp.status == 200) {
                            data[name] = xmlhttp.responseText;
                            
                            for(let i = 1; i <= 20; i++)
                                if(data[i] == undefined) return;
                            for(let i = 1; i <= 20; i++)
                                data[i] = JSON.parse(data[i]);

                            update();
                       }
                    }
                };
                xmlhttp.open("GET", url, true);
                xmlhttp.send();
            }

            for(let i = 1; i <= 20; i++)
                get(`https://senka.com.ru/server/${i}`, i);
            
        </script>
    </body>
</html>